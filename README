# sfCacheTaggingPlugin #

@todo Memcache atomic method add insted of set/get locks
@todo smira.ru opinion when new objects is created

The `sfCacheTaggingPlugin` is a Symfony plugin to store cache with
associated tags to keep cache content up-to-date based by incrementing tag version when cache objects are edited/removed or new objects are ready to be a part of cache content.

## Description ##

Tagging a cache, is a concept that was invented in the one time by many developers
([Andrey Smirnoff](http://www.smira.ru), [Dmitryj Koteroff](http://dklab.ru/)
and probability by somebody else)

This software was developed push of Andrey Smirnoff`s theoretical work
["Cache tagging with Memcached (in Russian)"](http://www.smira.ru/tag/memcached/).
Some ideas are implemented in the real world (i.e. tag versions based on datetime
and microtime, cache hit/set logging, cache locking) and part of them are not
(atomic counter)

## Repository ##

 * plugin repository @ github [http://github.com/fruit/sfCacheTaggingPlugin](http://github.com/fruit/sfCacheTaggingPlugin "Repository")
 * plugin tickets @ github [http://github.com/fruit/sfCacheTaggingPlugin/issues](http://github.com/fruit/sfCacheTaggingPlugin/issues "Issues")

## Installation ##

Install the plugin

    $ ./symfony plugin:install sfCacheTaggingPlugin

## Setup ##

1.  Check ``sfCacheTaggingPlugin`` plugin is enabled in ``/config/ProjectConfiguration.class.php``

        <?php

        class ProjectConfiguration extends sfProjectConfiguration
        {
          public function setup()
          {
            # … other plugins
            $this->enablePlugins('sfCacheTaggingPlugin');
          }
        }

1.  Create new file ``/config/factories.yml`` or edit each application`s-level
    ``/apps/%app%/config/factories.yml`` file

    > Cache tagging work for you each time when you save/update/delete Doctrine
      record or fetch
them from DB.
      So you should enable caching (``sf_cache: true``) in the all
      applications you work with. I recommend you to create default ``factories.yml``
      for all applications you have by creating file ``/config/factories.yml`` (bellow will be this file content).
      Symfony will check this file and load it as default ``factories.yml``
      configuration to all applications you have in the project.

    > This is ``/config/factories.yml`` content (you can copy&past this code into your
      brand new created file) or merge this config with each application`s
      ``factories.yml`` (applications, where you need to data be fetched/written from/to cache)

    > ### Example: file ``/config/factories.yml``

        all:
          view_cache:
            class: sfTagCache
            param:
              logging: true                 # logging is enabled ("false" to disable)
              cache:                        # Content will be stored in Memcache
                class: sfMemcacheCache      # Here you can switch to any other backend
                param:                      # (see Restrictions block for more info)
                  persistent: true
                  storeCacheInfo: false
                  host: localhost
                  port: 11211
                  timeout: 5
                  lifetime: 86400
              locker:                       # Locks will be stored in APC
                class: sfAPCCache           # Here you can switch to any other backend sf*Cache
                param:                      # (see Restrictions block for more info)
                  lifetime: 5

          view_cache_manager:
            class: sfViewCacheTagManager          # Extended sfViewCacheManager class
            param:
              cache_key_use_vary_headers: true
              cache_key_use_host_name:    true

    > **Easter eggs**: If you remove "``all_view_cache_param_locker``" section,
      locker will be the same as section "all_view_cache_param_cache".

    > **Restrictions**: Backend`s class should be inheritable from ``sfCache``
      class. Also, it should support the caching of objects and/or arrays.

    > **Bonus**: In additional to this plugin comes ``sfFileTaggingCache``
      and ``sfSQLiteTaggingCache`` which are ready to use them as backend class.

      This classes already have serialization/unserialization support.

1.  Edit Symfony`s predefined application`s-level ``factories.yml`` files

    > If you have audited each application`s-level ``factories.yml`` file in
      2nd step - go to 4th step.

    > In each application you want to use cache tagging, please, remove
      "``all_view_cache_manager``" section (you have already configured them
      in global ``/config/factories.yml`` file).

1.  Add "Cachetaggable" behavior to each model, which you want to be a part of cache content.

    > ### Exmaple: file ``/config/doctrine/schema.yml``

        BlogPost:
          tableName: blog_post
          actAs:
            Cachetaggable: ~
            #Cachetaggable:
            #  uniqueColumn: id               # you can customize unique column name (default is "id")
            #  versionColumn: object_version  # you can customize column name to store versions (default is "object_version")
          columns:
            id:
              type: integer
              primary: true
              autoincrement: true
              unsigned: true
            title: string(255)
          relations:
            BlogPostComment:
              class: BlogPostComment
              type: many
              local: id
              foreign: blog_post_id
              cascade: [delete]

        BlogPostComment:
          tableName: blog_post_comment
          actAs:
            Cachetaggable: ~
          columns:
            id:
              type: integer
              primary: true
              autoincrement: true
              unsigned: true
            blog_post_id:
              type: integer
              unsigned: true
              notnull: false
            author: string(20)
            message: string(255)
          indexes:
            blog_post_id: { fields: [blog_post_id] }

1.  Enable cache in ``settings.yml``

    > To setup cache, often, used a separate environment named "cache",
      but in the same way you can do it in any other environments which you have.

        prod:
          .settings:
            cache: true

        cache:
          .settings:
            cache: true

        all:
          .settings:
            cache: false

## Using ##

*   ### Native use:

        # Somewhere in frontend you need to output latest 3 posts
        $posts = Doctrine::getTable('BlogPost')
          ->createQuery()
          ->orderBy('id DESC')
          ->limit(3)
          ->execute();

        # write data to the cache ($posts is instance of the Doctrine_Collection_Cachetaggable)
        $tagger->set('my_posts', $posts, null, $posts->getTags());

        # fetch latest post
 to edit it
        $post = posts->getFirst();

        # prints something like "12607059650629789696"
        print $post->getObjectVersion();

        $post->setTitle('How to use sfCacheTaggingPlugin');

        # save and update/upgrade version of the tag
        $post->save();

        # prints something like "12607229083969089536" (new version of the tag)
        print $post->getObjectVersion();

        # will return null
        # $post object was updated, so, all $posts in cache "my_posts” is invalidated automatically)
        if ($data = $tagger->get('my_posts'))
        {
          # this block will not be executed
        }

        # save new data to the cache
        $tagger->set('my_posts', $posts, null, $posts->getTags());

        # will return data (objects are fresh)
        if ($data = $tagger->get('my_posts'))
        {
          # this code block will be executed
        }

        $post = new BlogPost();
        $post->setTitle('New post should be in inserted to the cache results');
        $post->save();

        # will return null, because 'my_posts' cache knows that it contains BlogPost objects
        # and listens on new objects with same type that are newer
        if ($data = $tagger->get('my_posts'))
        {
          # this block will not be executed
        }

        $posts = Doctrine::getTable('BlogPost')
          ->createQuery()
          ->orderBy('id DESC')
          ->limit(3)
          ->execute();

        $tagger->set('my_posts', $posts, null, $posts->getTags());

        # will return data
        if ($data = $tagger->get('my_posts'))
        {
          # this block will be executed
        }


*   ### non-Doctrine use:

    ##### indexSuccess.php

        <fieldset>
          <legend>Daylight</legend>

          <?php if (! cache_tag('daylight_content')) { ?>

            <h1>Text to cache No-<?php rand(1, 1000000) ?></h1>

            Text text text text text text text text text text text text text.
            <?php cache_tag_save(array('sun' => time(), 'moon' => time())); ?>
          <?php } ?>

        </fieldset>

    ##### code.php

          # when you want to update Daylight content
          $this->getContext()->getViewCacheManager()->getTagger()->setTag('moon', time());

</fieldset>

*   ### Using with partials:

        <fieldset>
          <legend>Partial</legend>

          <?php if (! cache_tag('latest-blog-posts-index-on-page')) { ?>
            <?php foreach ($posts as $post) { ?>
              <?php include_partial('posts/one_post', array('post' => $post) ?>
            <?php } ?>
            <?php cache_tag_save($posts->getTags()); ?>
          <?php } ?>

        </fieldset>

*   ### Using with components (simple):

    ##### indexSuccess.php

        <fieldset>
          <legend>Component</legend>

          <?php if (! cache_tag('latest-blog-posts-index-on-page')) { ?>
            <?php include_component_tag('posts', 'listOfPosts') ?>
            <?php cache_tag_save(); ?>
          <?php } ?>

        </fieldset>


    ##### components.class.php

        <?php

        class postsComponents extends sfComponents
        {
          public function executeListOfPosts($request)
          {
            $posts = Doctrine::getTable('BlogPost')
              ->createQuery('bp')
              ->select('bp.*')
              ->orderBy('bp.id DESC')
              ->limit(3)
              ->execute();

            $this->getContext()->getViewCacheManager()->setTags($posts->getTags());

            $this->posts = $posts;
          }
        }

*   ### Using with components (complex - Combining posts with comments)

    ##### components.class.php

        <fieldset>
          <legend>Component (posts and comments)</legend>

          <?php if (! cache_tag('posts_and_comments')) { ?>
            <?php include_component_tag('post', 'listOfPostsAndComments') ?>
            <?php cache_tag_save(); ?>
          <?php } ?>

        </fieldset>

    ##### components.class.php

        <?php

        class postsComponents extends sfComponents
        {
          public function executeListOfPostsAndComments($request)
          {
            $posts = Doctrine::getTable('BlogPost')
              ->createQuery('bp')
              ->addSelect('bp.*, bpc.*')
              ->innerJoin('bp.BlogPostComments bpc')
              ->orderBy('bp.id DESC')
              ->limit(3)
              ->execute();

            foreach ($posts as $post)
            {
              # 1st variant (shorter)
              # our cache should be updated if one of comment will be edited/deleted
              # therefore, we are collecting comment`s tags

              $posts->addTags($post->getBlogPostComment()->getTags());
              # or shorter
              # $posts->addTags($post->getBlogPostComment());
            }

            $this->getContext()->getViewCacheManager()->setTags($posts->getTags());

            $this->posts = $posts;
          }
        }

## Unit test ##

 * Unit tests (400 of 400) successfully completed

## Contacts ##

* @: Ilya Sabelnikov `` <fruit dot dev at gmail doc com> ``
* IRC: irc.freenode.net, #symfony, fruit
* skype: ilya_roll