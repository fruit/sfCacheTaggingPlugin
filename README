# sfCacheTaggingPlugin #

The `sfCacheTaggingPlugin` is a symfony plugin to store caches associated with unique tags to keep cache content up-to-date based by incrementing tag version.

## Description ##

Cache tagging is a concept that was invented in one time by many developers
  ([Andrey Smirnoff](http://www.smira.ru), [Dmitryj Koteroff](http://dklab.ru/) and probability by some other people)

This software was developed push of Andrey Smirnoff`s theoretical work ["Cache tagging with Memcached (in Russian)"](http://www.smira.ru/tag/memcached/).
Some ideas are implemented in the real world (i.e. tag versions based on datetime and microtime, cache hit/set logging, cache locking) and part of them are not implemented (atomic counter)

## Repository ##

 * plugin repository @ github [http://github.com/fruit/sfCacheTaggingPlugin](http://github.com/fruit/sfCacheTaggingPlugin "Repository")
 * plugin tickets @ github [http://github.com/fruit/sfCacheTaggingPlugin/issues](http://github.com/fruit/sfCacheTaggingPlugin/issues "Issues")

## Installation ##

Install the plugin

    $ ./symfony plugin:install sfCacheTaggingPlugin

## Setup ##

1.  Check ``sfCacheTaggingPlugin`` plugin is enabled in ``/config/ProjectConfiguration.class.php``

        <?php

        class ProjectConfiguration extends sfProjectConfiguration
        {
          public function setup()
          {
            # â€¦ other plugins
            $this->enablePlugins('sfCacheTaggingPlugin');
          }
        }

1.  Create new file ``/config/factories.yml``  or edit each applications-level ``/apps/%app%/config/factories.yml`` file

    > Cache tagging work for you when you save/update Doctrine record or fetch them from DB. So you should enable caching (``sf_cache: true``) in the all applications you work with. I recommend You to create default factories.yml for all application you have by creating empty file ``/config/factories.yml``. Symfony will check this file and load it as default factories.yml configuration to all applications you have in the project.

    > This is /config/factories.yml content (you can copy & past it into your brand new created file) or merge this config with each application factories.yml where data will be fetched from the cache or written to the cache:

    > ### Example: file ``/config/factories.yml``

        all:
          view_cache:
            class: sfTagCache
            param:
              logging: true                 # logging is enabled (false to disable)
              cache:                        # Content will be stored in Memcache
                class: sfMemcacheCache      # Here you can switch to any other backend
                param:                      # (see Restrictions block for more info)
                  persistent: true
                  storeCacheInfo: false
                  host: localhost
                  port: 11211
                  timeout: 5
                  lifetime: 86400
              locker:                       # Locks will be stored in APC
                class: sfAPCCache           # Here you can switch to any other backend sf*Cache
                param:                      # (see Restrictions block for more info)
                  lifetime: 5

          view_cache_manager:
            class: sfViewCacheTagManager          # Extended sfViewCacheManager class
            param:
              cache_key_use_vary_headers: true
              cache_key_use_host_name:    true

    > **Easter eggs**: If you remome "``all_view_cache_param_locker``" section, locker will be the same as "all_view_cache_param_cache" section.

    > **Restrictions**: Backend class should be inheritable from ``sfCache`` class. It should support to cache objects/arrays.

    > **Bonus**: In additional to this plugin commes ``sfFileTaggingCache`` and ``sfSQLiteTaggingCache`` which are ready to use them as backend class.

1.  Edit Symfony`s predefined applications-level ``factories.yml`` files

    > If you have addited each applications-level ``factories.yml`` file in 2nd step - go to 4th step.

    > In each application you want to use cache tagging, remove "``all_view_cache_manager``" section (you have already configured them in global ``/config/factories.yml`` file).

1.  Add "Cachetaggable" behavior to each models you want to be a part of cache.

    > ### Exmaple: file ``/config/doctrine/schema.yml``

        BlogPost:
          tableName: blog_post
          actAs:
            Cachetaggable: ~
            #Cachetaggable:
            #  uniqueColumn: id               # you can setup you unique column name (default is "id")
            #  versionColumn: object_version  # and custom column name to store versions (default is "object_version")
          columns:
            id:
              type: integer
              primary: true
              autoincrement: true
              unsigned: true
            title: string(255)
          relations:
            BlogPostComment:
              class: BlogPostComment
              type: many
              local: id
              foreign: blog_post_id
              cascade: [delete]

        BlogPostComment:
          tableName: blog_post_comment
          actAs:
            Cachetaggable: ~
          columns:
            id:
              type: integer
              primary: true
              autoincrement: true
              unsigned: true
            blog_post_id:
              type: integer
              unsigned: true
              notnull: false
            author: string(20)
            message: string(255)
          indexes:
            blog_post_id: { fields: [blog_post_id] }

1.  Enable cache in ``settings.yml``

    > To setup cache is usually used a separate environment "cache",
      but in the same way you can do it in any other enviroment which you have.

        prod:
          .settings:
            cache: true

        cache:
          .settings:
            cache: true

        all:
          .settings:
            cache: false

1.  Configure cache keys realation to Doctrine objects in ``/config/app.yml``

    > Creating a new cache, you must specify what types of objects stored in them.
      This is required to ensure that new facilities, which could be in them, reported to
      the cache that appeared completely new information and need to rebuild the cache.

    > Here is example how to do this:

        all:
          sfcachetaggingplugin:
            containers:
              BlogPost:
                - index-blog-posts-component
                - index-blog-posts-with-comments-component
                - index-blog-posts-with-comments-slot-component
              BlogPostComment:
                - index-blog-posts-with-comments-component
                - index-blog-posts-with-comments-slot-component

    > This is enought to sfCacheTaggingPlugin starts listening on creation of the new
      objects, which are linked existing cache keys.
      Cache key could be appeared many times on others Doctrin_Record classes.

## Using ##

*   ### Native use:

        # Somewhere in frontend you need to output latest 3 posts
        $posts = Doctrine::getTable('BlogPost')
          ->createQuery()
          ->orderBy('id DESC')
          ->limit(3)
          ->execute();

        # write them to cache backend ($posts is instance of the Doctrine_Collection_Cachetaggable)
        $tagger->set('my_posts', $posts, null, $posts->getTags());

        # i want to change title of your latest post
        $post = posts->getFirst();

        # prints something like "12607059650629789696"
        print $post->getObjectVersion();

        $post->setTitle('How to use sfCacheTaggingPlugin');

        # this will say to backend, to expire tag associated to this blog post
        # all cache that have this tag in his tag list, will be invalidated
        $post->save();

        # prints something like "12607229083969089536" (new version)
        print $post->getObjectVersion();

        # will return null ($post object is updated)
        if ($data = $tagger->get('my_posts'))
        {
          # this block will not be executed
        }

        # save new data to cache
        $tagger->set('my_posts', $posts, null, $posts->getTags());

        # will return data (objects are fresh)
        if ($data = $tagger->get('my_posts'))
        {
          # this code block will be runned
        }

        # If you create new post, you probably want to cache 'my_posts' will be expired automatically
        # But new $post object tag never was used before, so any existed caches could not
        # understand - does this content is linked to new object $post
        # To resolve this problem, you need to declare cache index relations with object classes
        # See more info how to do this in the 6th step of the Setup

        # For example, app.yml is looked like:

        #all:
        #  sfcachetaggingplugin:
        #    containers:
        #      BlogPost: [my_posts]

        $post = new BlogPost();
        $post->setTitle('New post should be in inserted to the cache results');
        $post->save();

        # will return null (new $post is typeof BlogPost and linked to "my_posts")
        if ($data = $tagger->get('my_posts'))
        {
          # this block will not be executed
        }

        $posts = Doctrine::getTable('BlogPost')
          ->createQuery()
          ->orderBy('id DESC')
          ->limit(3)
          ->execute();

        $tagger->set('my_posts', $posts, null, $posts->getTags());

        # will return data
        if ($data = $tagger->get('my_posts'))
        {
          # this block will be executed
        }


*   ### Using with partials:

        <fieldset>
          <legend>Partial</legend>

          <?php if (! cache_tag('latest-blog-posts-index-on-page')) { ?>
            <?php foreach ($posts as $post) { ?>
              <?php include_partial('posts/one_post', array('post' => $post) ?>
            <?php } ?>
            <?php cache_tag_save($posts->getTags()); ?>
          <?php } ?>

        </fieldset>

*   ### Using with components (simple):

    ##### indexSuccess.php

        <fieldset>
          <legend>Component</legend>

          <?php if (! cache_tag('latest-blog-posts-index-on-page')) { ?>
            <?php include_component_tag('posts', 'listOfPosts') ?>
            <?php cache_tag_save(); ?>
          <?php } ?>

        </fieldset>


    ##### components.class.php

        <?php

        class postsComponents extends sfComponents
        {
          public function executeListOfPosts($request)
          {
            $posts = Doctrine::getTable('BlogPost')
              ->createQuery('bp')
              ->select('bp.*')
              ->orderBy('bp.id DESC')
              ->limit(3)
              ->execute();

            $this->getContext()->getViewCacheManager()->setTags($posts->getTags());

            $this->posts = $posts;
          }
        }

*   ### Using with components (complex - Combining posts with comments)

    ##### components.class.php

        <fieldset>
          <legend>Component (posts and comments)</legend>

          <?php if (! cache_tag('posts_and_comments')) { ?>
            <?php include_component_tag('post', 'listOfPostsAndComments') ?>
            <?php cache_tag_save(); ?>
          <?php } ?>

        </fieldset>

    ##### components.class.php

        <?php

        class postsComponents extends sfComponents
        {
          public function executeListOfPostsAndComments($request)
          {
            $posts = Doctrine::getTable('BlogPost')
              ->createQuery('bp')
              ->addSelect('bp.*, bpc.*')
              ->innerJoin('bp.BlogPostComments bpc')
              ->orderBy('bp.id DESC')
              ->limit(3)
              ->execute();

            foreach ($posts as $post)
            {
              # 1st variant (shorter)
              # our cache should be updated if one of comment will be edited/deleted
              # therefore, we are collecting comment`s tags

              $posts->addTags($post->getBlogPostComment()->getTags());
              # or shorter
              # $posts->addTags($post->getBlogPostComment());
            }

            $this->getContext()->getViewCacheManager()->setTags($posts->getTags());

            $this->posts = $posts;
          }
        }

## Unit test ##

 * Unit tests (400 of 400) successfully completed

## Contacts ##

@: Ilya Sabelnikov <fruit dot dev at gmail doc com>
IRC: irc.freenode.net, #symfony, fruit
skype: ilya_roll